// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.OpenSsl;

namespace McMaster.DotNet.Serve
{
    class CertificateLoader
    {
        // see https://github.com/aspnet/Common/blob/61320f4ecc1a7b60e76ca8fe05cd86c98778f92c/shared/Microsoft.AspNetCore.Certificates.Generation.Sources/CertificateManager.cs#L19-L20
        // This is the unique OID for the developer cert generated by VS and the .NET Core CLI
        private const string AspNetHttpsOid = "1.3.6.1.4.1.311.84.1.1";
        private const string AspNetHttpsOidFriendlyName = "ASP.NET Core HTTPS development certificate";

        public const string DefaultCertPemFileName = "cert.pem";
        public const string DefaultPrivateKeyFileName = "private.key";
        public const string DefaultCertPfxFileName = "cert.pfx";

        public static bool TryLoadCertificate(
            CommandLineOptions options,
            string currentDirectory,
            out X509Certificate2 cert,
            out Exception error)
        {
            cert = null;
            error = null;

            if (!options.UseTls)
            {
                return true;
            }

            try
            {
                cert = LoadCertificate(options, currentDirectory);
                if (!cert.HasPrivateKey)
                {
                    throw new InvalidOperationException($"The certificate '{cert.SubjectName.Name} ({cert.Thumbprint})' is missing a private key.");
                }
                return true;
            }
            catch (Exception ex)
            {
                error = new InvalidOperationException($"Failed to configure the HTTPS. {ex.Message}", ex);
                return false;
            }
        }

        private static X509Certificate2 LoadCertificate(CommandLineOptions options, string currentDirectory)
        {
            if (!string.IsNullOrEmpty(options.CertPfxPath))
            {
                options.ExcludedFiles.Add(options.CertPfxPath);
                return LoadFromPfxFile(options.CertPfxPath, options.CertificatePassword);
            }

            if (!string.IsNullOrEmpty(options.CertPemPath))
            {
                options.ExcludedFiles.Add(options.CertPemPath);
                var privateKeyPath = !string.IsNullOrEmpty(options.PrivateKeyPath)
                    ? options.PrivateKeyPath
                    : Path.Combine(Path.GetDirectoryName(options.CertPemPath), DefaultPrivateKeyFileName);
                options.ExcludedFiles.Add(privateKeyPath);
                return LoadFromPem(options.CertPemPath, privateKeyPath);
            }

            var defaultCertFile = Path.Combine(currentDirectory, DefaultCertPemFileName);
            var defaultKeyFile = Path.Combine(currentDirectory, DefaultPrivateKeyFileName);
            if (File.Exists(defaultCertFile) && File.Exists(defaultKeyFile))
            {
                options.ExcludedFiles.Add(defaultCertFile);
                options.ExcludedFiles.Add(defaultKeyFile);
                return LoadFromPem(defaultCertFile, defaultKeyFile);
            }

            var defaultPfxFile = Path.Combine(currentDirectory, DefaultCertPfxFileName);
            if (File.Exists(defaultPfxFile))
            {
                options.ExcludedFiles.Add(defaultPfxFile);
                return LoadFromPfxFile(defaultPfxFile, options.CertificatePassword);
            }

            if (options.ShouldUseLocalhost())
            {
                var retVal = LoadDeveloperCertificate();
                if (retVal != null)
                {
                    return retVal;
                }
            }

            throw new InvalidOperationException("Could not find a certificate to use for HTTPS connections");
        }

        private static X509Certificate2 LoadFromPfxFile(string filepath, string password)
        {
            try
            {
                return new X509Certificate2(filepath, password);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"Failed to load certificate file from '{filepath}' with error '{ex.Message}'.", ex);
            }
        }

        private static X509Certificate2 LoadFromPem(string certPath, string keyPath)
        {
            try
            {
                using var certWithoutPrivateKey = new X509Certificate2(certPath);
                using var keyFile = File.OpenText(keyPath);
                // Workaround https://github.com/dotnet/corefx/issues/20414
                var pemReader = new PemReader(keyFile);

                var pemObj = pemReader.ReadObject();
                switch (pemObj)
                {
                    case RsaPrivateCrtKeyParameters rsaParams:
                        {
                            var rsa = CreateRSA(rsaParams);
                            // See https://github.com/dotnet/corefx/issues/24454#issuecomment-388231655
                            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                            {
                                using var certWithKey = certWithoutPrivateKey.CopyWithPrivateKey(rsa);
                                return new X509Certificate2(certWithKey.Export(X509ContentType.Pkcs12));
                            }
                            else
                            {
                                // Only works on Linux/macOS
                                return certWithoutPrivateKey.CopyWithPrivateKey(rsa);
                            }
                        }
                }

                throw new InvalidOperationException($"Failed to read private key from '{keyPath}'. Unexpected format: " + pemObj.GetType().Name);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"Failed to load certificate file from '{certPath}' and '{keyPath}'", ex);
            }
        }

        private static RSA CreateRSA(RsaPrivateCrtKeyParameters rsaParams)
        {
            try
            {
                return RSA.Create(new RSAParameters
                {
                    Modulus = rsaParams.Modulus.ToByteArray(),
                    Exponent = rsaParams.PublicExponent.ToByteArray(),
                    D = rsaParams.Exponent.ToByteArray(),
                    P = rsaParams.P.ToByteArray(),
                    Q = rsaParams.Q.ToByteArray(),
                    DP = rsaParams.DP.ToByteArray(),
                    DQ = rsaParams.DQ.ToByteArray(),
                    InverseQ = rsaParams.QInv.ToByteArray(),
                });
            }
            catch (CryptographicException)
            {
#if NETCOREAPP3_0
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                {
                    Console.Error.WriteLine("There are known issues loading PEM certificates on Windows with .NET Core 3.0. See https://github.com/natemcmaster/dotnet-serve/issues/27.");
                }
#endif
                throw;
            }
        }

        private static X509Certificate2 LoadDeveloperCertificate()
        {
            using var store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);
            var certs = store.Certificates.Find(X509FindType.FindByExtension, AspNetHttpsOid, validOnly: false);
            if (certs.Count == 1)
            {
                return certs[0];
            }

            if (certs.Count > 1)
            {
                throw new InvalidOperationException($"Ambiguous certficiate match. Multiple certificates found with extension '{AspNetHttpsOid}' ({AspNetHttpsOidFriendlyName}).");
            }

            return null;
        }
    }
}
